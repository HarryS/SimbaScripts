{///////////////////////////////////////////////////////////////////////////////
//                                                                            //
//                        Harry's Catacomb Grabber v1.1                       //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  Setup: Position http://i.imgur.com/hzcAk.jpg (last chamber in catacombs)  //
//         Wear a sling + range boosting armour OR autocast your own spell.   //
//         You MIGHT die, so do not wear anything you can't afford to lose.   //
//         You MUST have stolen the statue at least once:                     //
//           (grab it+kill him legit+grab statue, then it's an empty counter) //
//         Make sure you are on lowest grafix settings+highest brightness.    //
//        After that, you're probably good to go! Watch it a few times.       //
//                                                                            //
//  Good things to do: GIVE ME SOME BLOODY PROGRESS REPORTS IN THE THREAD!    //
//                       And report any critical bugs you happen to find.     //
//                                                                            //
//  My to-do list: None!  Item pickup will probably never be done for         //
//    the public due to goldfarming scumbags; please don't request for it!    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  Changelog:                                                                //
//      0.1: Initial release.                                                 //
//      0.2: Fixed world-switching. Also added a click to walk back to the    //
//             plinth if you get pulled off it for some reason.               //
//      0.3: Fixes rare RS bug where monster won't attack you. Takes          //
//             screenshots when problems in the script happen. Optional food  //
//             eating - be warned, you may still die even with food!          //
//      0.4: Very tiny bug fixed.                                             //
//      0.5: Large update! Deathwalk and improved object finding,             //
//             all thanks to DemiseScythe's awesome DTMs! Script will also    //
//             set the highest FPS for the RS client, says current status in  //
//             status section (under debug box), and some small bug fixes.    //
//             Overall should attack much quicker, giving more exp/hr!        //
//      0.6: Fixed small bug that broke anti-fight detector.                  //
//      0.7: Made deathwalk fail 95% less often. Much better statue finding.  //
//      0.8: SRL-5 update required. Smoothed out deathwalk even more. Item    //
//              pickup added (burries bones and grabs coins) - will reduce    //
//              exp/hr, so I suggest you keep it disabled.                    //
//      0.9: Deathwalk pretty much perfect. Hopefully last update about this. //
//      1.0: Turns off ugly onscreen XP popups (terrible update Jagex, really //
//              ugly). Also supports new XP counter - make sure your fonts    //
//              in Simba are up-to-date!                                      //
//      1.1: Fixed DTM.                                                       //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//   Script License: WTFPL - Do What The Fuck You Want To Public License.     //
//                                                                            //
//      This program is free software. It comes without any warranty, to the  //
//      extent permitted by applicable law. You can redistribute it and/or    //
//      modify it under the terms of the Do What The Fuck You Want To Public  //
//      License, Version 2, as published by Sam Hocevar. See                  //
//      http://sam.zoy.org/wtfpl/COPYING for more details.                    //
//                                                                            //
///////////////////////////////////////////////////////////////////////////////}

program HarrysCatacomber;
{$DEFINE SMART}
{$i SRL/SRL.simba}
{$i SRL/SRL/Misc/PaintSmart.simba}

procedure DeclarePlayers;
begin
  HowManyPlayers := 1;
  CurrentPlayer := Random(HowManyPlayers);
  NumberOfPlayers(HowManyPlayers);

  with Players[0] do
  begin
    Name        := 'Username';
    Pass        := 'Password';
    Member      := False;
    Nick        := 'nick';
    Active      := True;
  end;

end;

const
  SERVER  = 61;     // Enter "0" to pick a random server.
  SIGNED  = True;  // Use the signed RS-client? Leave at True unless you know what you're doing.
  MEMBERS = False; // Set to True if using a RS-Members account. False if F2P.
  WORLD_SWITCH = True; // Switch world when connecting to RS?
  WORLD_LEAVE = True; // Hop words every ~25 minutes or so. WORLD_SWITCH must be true.
  TrainLowest = False; // Train lowest combat mode? Disable(set to False) if using range/mage.
  ClearTime = 20; // Clears debug window every X minutes.
  EatFoods = True; // Eats lobsters if it detects your HP as being low. BETA. *YOU MAY STILL DIE*
  GetScreenies = True; // Take screenies when stuff that might be interesting happen. These are useful for me if you get a bug, so please leave enabled!
  GrabBones = False; // Pickup and bury bones? Will get you a lot more random events, so be warned.
  DrawDebugs = True; // Paint on SMART window for object finding, etc.

  Autochecken = True; // Automatically check for updates and download the newer version of the script if it gets updated.

  SRLStats_Username = ''; // Your SRL Stats Username (not RS!) - get one at http://stats.villavu.com/
  SRLStats_Password = ''; // Your SRL Stats Password (not RS!) - get one at http://stats.villavu.com/


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//   End of Basic Setup - you may continue down more IF you know what you're  //
//          doing. If not, you will probably break something!...              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

  MOUSE_SPEED              = 15;
  MOUSE_SPEED_RANDOMNESS   = 7;
  // Mouse speed will be "MOUSE_SPEED + Random(MOUSE_SPEED_RANDOMNESS);".

  DebugMe = False; // Get advanced debugs of current procedures. Not suggested.

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//   End of Advanced Setup - really, do NOT touch anything below this....     //
//           or you will probably break something......... :)                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

  SCRIPT_NAME        = 'Catacomb Grabber';
  SCRIPT_VERSION     = '1.1';

var PlayerSessionTime,ReportTimer,AntiBansGlobal, MonstersKilledGlobal, ExpGainGlobal, xxx,yyy,
     WorldLeaveMarker, DethWelks, StatsTimer, thetries, YesS,NoS,Herz, DTMFsf, BonesBurriedGlobal,
     ProperLog, ReportClear, lasthpbar,tmpbarz : integer; aFound: Extended; sonic,KilledYou: boolean;

function FindDTMRotatedFailSafe(DTM: Integer; var x, y: Integer; x1, y1, x2, y2: Integer; sAngle, eAngle, aStep: Extended; out aFound: Extended): boolean;
begin;
  result := FindDTMRotatedAlternating(DTM,x,y,x1,y1,x2,y2,sangle,eangle,astep,afound);
  if (Result) then
  begin
    MarkTime(DTMFsf);
    Exit;
  end;
  if not LoggedIn then
    Result := True;
  if (Result) then
  begin
    WriteLn('Detected as logged out ... try again in a sec.');
    Wait(1000+Random(2000));
    if not LoggedIn then
    begin
      WriteLn('You logged out somehow, something is probably wrong, bye!');
      Logout;
      LeaveLobby;
      Exit;
    end else
    begin
      Result := False;
      WriteLn('You are still logged in, false alarm...');
      Exit;
    end;
  end;
  Result := (TimeFromMark(DTMFsf) > (60000+Random(20000)-Random(20000)));
  if (Result) then
  begin
    WriteLn('1 minute without finding DTM, something is wrong...');
    Logout;
    LeaveLobby;
    Exit;
  end;
end;

procedure screwcompass;
begin
  //MakeCompass('rand');
  if (Random(2)=0)then
  begin
    KeyDown(VK_Left);
    Wait(100+Random(500));
    KeyUp(VK_Left);
  end else
  begin
    KeyDown(VK_Right);
    Wait(100+Random(500));
    KeyUp(VK_Right);
  end;
  Wait(100+Random(500));
  MakeCompass('e');
end;

Function FindFlagH(var X, Y: integer): Boolean; // Narcle. I inc'd the tol
begin
  Result := False;
  if FindBitmapToleranceIn(bmpFlag, X, Y, MMX1, MMY1, MMX2, MMY2, 75) then
  begin
    Result := True;
    X := X+4;
    Y := Y+8;
   end;
end;

function FlagPresentH: Boolean; // weequ
var
  X, Y: Integer;
begin
  Result := FindFlagH(X, Y) or FindFlag2(X, Y);
end;

procedure insideMMClick(ggx,ggy,randx,randy: integer; tclik:boolean);
begin
  if PointInBox(point(ggx,ggy), inttobox(MMX1,MMY1,MMCX,MMCY)) then // northwest
  begin
    Mouse(ggx+9,ggy+9,randx,randy,tclik);
    writeln('Northwest MM Click.');
    exit;
  end;

  if PointInBox(point(ggx,ggy), inttobox(MMCX,MMCY,MMX2,MMY2)) then // southeast
  begin
    Mouse(ggx-9,ggy-9,randx,randy,tclik);
    writeln('Southeast MM Click.');
    exit;
  end;

  if PointInBox(point(ggx,ggy), inttobox(MMX1,MMCY,MMCX,MMY2)) then // southwest
  begin
    Mouse(ggx+9,ggy-9,randx,randy,tclik);
    writeln('Southwest MM Click.');
    exit;
  end;

  if PointInBox(point(ggx,ggy), inttobox(MMCX,MMY1,MMX2,MMCY)) then // northeast
  begin
    Mouse(ggx-9,ggy+9,randx,randy,tclik);
    writeln('Northeast MM Click.');
    exit;
  end;
  writeLn('This shouldn''t happen! point: '+tostr(ggx)+','+tostr(ggy));

end;

Function BuryBones: Boolean; // Narcle!
var
  i, x, y, t,iix1,iiy1,iix2,iiy2: integer; invboxi:tbox;
begin
  if not GrabBones then
    Exit;
  SetColorToleranceSpeed(1);
  SetColorspeed2Modifiers(0.2,0.2);

  for i := 1 to 28 do
  begin
    invboxi := InvBox(i);
    iix1:=invboxi.X1;
    iiy1:=invboxi.Y1;
    iix2:=invboxi.X2;
    iiy2:=invboxi.Y2;

    if FindColorTolerance(x,y,10000543,iix1,iiy1,iix2,iiy2,30) then
    begin
      WriteLn('Moving to position '+tostr(i));
      MMouseItem(i);
      if WaitUpText('ury', 500) then
      begin
        Inc(Players[CurrentPlayer].Integers[57]);
        Inc(BonesBurriedGlobal);
        stats_incVariable('Bones (Burried)',1);
        GetMousePos(x, y);
        Mouse(x, y, 0, 0, true);
        Wait(900+random(300));
        t := GetSystemTime;
        while ExistsItem(i) and ((GetSystemTime-t) < 450) do
          wait(75 + random(50));
        if (GetSystemTime - t) >= 450 then //We cannot bury at this place..
        begin
          //writeln('No bury.');
          Result := false;
          //Exit;
        end;
        Result := true;
      end;
    end;
  end;
end;

function CustomPickup:boolean; // Narcle!
var
  i, L, m, H,mmx,mmy,flagtimes:integer;
  T: TPoint;
  BoxArr: TBoxArray;
  MBox: TBox;
  Items, TPA: TPointArray;
  CaseTrue: boolean;
  ATPA: T2DPointArray;
begin
  if not GrabBones then
    Exit;

  Items := GetMMDotsOnMS('item');
  L := Length(Items);
  if L < 1 then
    Exit;

  SetLength(BoxArr, L);
  for i := 0 to L-1 do
  begin
    T := MMtoMS(Items[i]);
    BoxArr[i] := IntToBox(Max(T.x-40, MSX1), Max(T.y-40, MSY1), Min(T.x+40, MSX2), Min(T.y+40, MSY2));
  end;

  H := High(Players[CurrentPlayer].Arrays[2]);

  for m := 0 to L-1 do
  begin
    if InvFull then//check
    begin
      BuryBones;
      if InvFull then begin WriteLn('Inv still full, oops!'); Exit; end;
    end;

    begin
      CaseTrue := false;
      SetColorToleranceSpeed(2);
      SetColorspeed2Modifiers(0.27, 1.87);
      with BoxArr[m] do
        CaseTrue := FindColorsTolerance(TPA, 13094113, X1, Y1, X2, Y2, 13);

      if not CaseTrue then
        Continue;

      ATPA := SplitTPA(TPA, 3);
      SortATPASize(ATPA, True);
      MBox := GetTPABounds(ATPA[0]);
      T := MiddleBox(MBox);
    end;

    if PointInBox(T, IntToBox(240, 137, 278, 185)) or
      PointInBox(T, IntToBox( 410, 53, MSX2, 72)) or
      PointInBox(T, IntToBox( 0, 0, 100, 25)) then
        Continue;

    //ClearCanvas(SMART_Canvas.canvas, MSX2, MSY2); // could not call proc error a lot, not sure why
    if DrawDebugs then
    begin
      SMART_DrawBoxEx(True, BoxArr[m], clYellow);
      SMART_DrawBoxEx(False, MBox, clRed);
    end;

    with MBox do
      MouseBox(x1, y1, x2, y2, 3);

    if WaitUpTextMulti(['Take'], 100+random(50)) then
    begin
      GetMousePos(mmx,mmy);
      Mouse(mmx,mmy,0,0,False);
      if WaitOptionMultiEx(['oins','Rune','ones'], 'All', ClickLeft, 1000) then
      begin
        Result := True;
        Writeln('Picking up item');
        SetColorToleranceSpeed(1);
        SetColorspeed2Modifiers(0.2,0.2);
        marktime(flagtimes);
        while (timefrommark(flagtimes) < 1500) do
         FlagPresentH;
        if (timefrommark(flagtimes) > 1500) then writeln('breakin');
        Wait(100+random(600));
      end;
    end;
  end;

end;

function DoDeathWalk: string;
var
  xz, yz, blkcolor: Integer;
  Q: Array [0..10] of Integer;
  K: Array [0..2] of Integer;
begin
  Result := 'NotWalked';
  Q[0] := DTMFromString('mrAAAAHic42BgYJjGxMDQCMQJQJwHxClAnAHE84A4EojlgWpsgdgeiGWAWAOI/YA4AIgVgTg8MIShu7mVYVJXD5jt7qzDYG2kxeACpEF8fqAafJiRAIYBAA2ADg4=');
  Q[1] := DTMFromString('mggAAAHicY2NgYHAAYicgFmKAAFYgNgRiJiBOAGJtIBYGYk6ofFK8C4OTtyaDupYKg6uTIUNodAiDtZ0BAz9QDhtmxIEhAADk3gZv');
  Q[2] := DTMFromString('mEQIAAHicvc0hC8JgAITh07AqYloy6C8YqFgsuuoMDjRvujSzbKJ1KIhBxGS1LG34/3wHXzXOg6ccHGdLejelIwp8jCdOSHDFBSVyvEyXIoKHCQZwMMQUC4Q4oM+PjxFmWGKDEC4cdLHFHhluuOOBs+mrzRxj9GCjgzbWK0+7OJBlqTYt1a/xBz/zBS0rGTg=');
  Q[3] := DTMFromString('mOwIAAHicvc2xCwEBFMfx3/EHyGKxUQalxEKKW5TrCJckm4FwGQ23yCJF6WYl+Qf4F32HN9vcq0/vvXq9X17SIyV18MIHb9xxtvmJm+1X7DGBhyaqqJkp+ta7uOCImf0vkHdCGw0EGMDDAgfEiLBEFjmUUEcPc6zs3kcFLRRRhmt3u3CrcLPWeDiSo/RfZchLipOgH/UF2/YZmg==');
  Q[4] := DTMFromString('mOwIAAHicvc8hC8JgFIXhO+0bWAwWly1LGhfWRbbxaRgTwbKgYwiGCRYHS5ahrCxZLJb9w73Cl23uwgOnHA53IiKHgUiGIyL4OOOGGi980GpvNLgjR6J7DhbwsEKIAHukKGCxl2GmjWFihCkceFBIcEWJCg88dV5iDhsuYpxwQY41dttYNkqJIcO/+/7VF6NHP64DlNkZew==');
  Q[5] := DTMFromString('mpAIAAHicxc4tC8JgFIbho/sBGsSyYhKDggg6sLxlSVAG4kczDBZmMwwERfzAMQSLFqMggkX0H3qH043vgSs8h+fAqYjIIy9yxAYHjNCDQQctNNFGFz4C7U0xwRB9rLDGDS988cEbT9xxRYY9EtT5oYEyiijBRQ0efIwRIcEOZ2wxw0B7Vc0BjO6M5hBLvT3hghQLzONQHEesKYhdOcv+zQ9aQhyL');
  Q[6] := DTMFromString('mjwIAAHicxc8hC8JwEMbh28A8FMQkSxYF04qwYraMDQwWmQhzsDUNW1zXYdjKyhCMfgC/nT/hgs34P3jCG+5ezhWRty3yQo87KpxxxBYbrBEgwg4JClzRqQYtnnigxgWx7oXw9N43p9jTv4SLMUZwMMQEU8ywgI8I8x8rBIiRokCFG1pVo0SCEzIckOeZWPbACEf/NMEy6M98ANJvG+A=');
  Q[7] := DTMFromString('mDQMAAHiczc49C0EBFMbx45ZZwiRZMGKwYJMwyEvKTVK3KKEbGZhuhrvIoJgoshikDAbfz1+dD2C8p3516jk9naSIfAyRO/bYwIaFFproooIcssiggDLq6GEKRzuueOCtvRfNfjcd1GBiiCVcHHDDC08M+KsPGyss1AgmSmigDQszrOFihyPOOOm+haN9VeQRRwJpRBFBCEGEEUNK8yLmk7H4xfCUAH95jc+D/pov2PwhtA==');
  Q[8] := DTMFromString('mjwIAAHicxc0ha0JhGAXgT/0BKhgEQaMICwaXhBWxGRQWhiAsqBiurKhhJm0GFYTBMLlh0ubC/p7P4PbF+8JT3sPhVEIIu3QIZ04c+ObCnnfGvNJnQMSSDZ98ceWHX25xp0uDKbO490KHJx7/9uyvmTPkmRYP1GhSp0SOPAWKlKnGeZs+ET1GTFiw58gHW1bx/20ahVTIJCJrPympBP1zd/VoHQQ=');
  Q[9] := DTMFromString('mzgIAAHiczc69CwEBGMfx5/gDbBZlEMqElJOBupTlFi+DUkqynpcYRLId7koUNgarUf4+3/LsRvfUp55+z9PTkxCRd0jkAB8uFtjhggeeeOl8gxm66KCNofY2qjCRQx4FlDSvo4E+pvBwwwl3DPilhRpMJBFFDClkUYaDJVbowUYRacR1P6OZhaZ8b4+xxhZHXNUZe8xRwWTkiCHhv4vwSxAYAfG7PnS8Hjc=');
  Q[10] := DTMFromString('mpAIAAHicxc6xCwFxGMbxl7qMihuUgcWmrkuWG5SIMmIwGO46udIlJkkZlMFgoa6bKZuSv9D36t2Nv7c+9dbz1PvWReSbF3nihhdSXHDGFnOMMEQfE4SaZZ07Hnhrr4MWPAwwRYQDEr3xwQ5j9PihDQ9LBJihC0dleRM1VFBGCTaqaMCFj5Xa44QrUiS6H7HGBjGihS8FyzKmyA8m5Qz7Nz9t6x4V');
  K[0] := DTMFromString('mWAAAAHicY2FgYPgIxKeAWJyRgUEEiG2BbBEg5gfiVCDm5eVlKCrIZWiqr2GIDPQFiyNjRjQMAgB+Dgbc');
  K[1] := DTMFromString('mlwAAAHicY2dgYLAB4lYGCLCC8kOBWAWItYBYD4gNoPKyQCwOxJIMqGDa5CaGm+f2MLTWlzC0N5Qy8APFcGFGPBgKAFacCf8=');
  K[2] := DTMFromString('mrAAAAHic42BgYGBlZGBgAeJfQDY3kGZGw6pALAfEEkAsxghRwwDE34DUayD28XRk4OPjBdN+3s4MoYGeDHFRgQwpCeEMNeXZDPxANfgwIwEMAwBPpgsv');
  try
    MouseSpeed := 18;
    MakeCompass('e');
    wait(100+Random(1000));
    MakeCompass('e');
    SetAngle(SRL_ANGLE_HIGH);
    SetRun(True);
    if not FindDTMRotatedFailSafe(Q[0], xz, yz, MMX1, MMY1, MMX2, MMY2, -Pi/4, Pi/4, Pi/60, aFound) and LoggedIn then
      Mouse(626, 60, 3, 3, True);
    FFlag(6);
    Writeln('Beginning Deathwalk by DemiseScythe');
    MarkTime(DTMFsf);
    if FindDTMRotatedFailSafe(Q[0], xz, yz, MMX1, MMY1, MMX2, MMY2, -Pi/4, Pi/4, Pi/60, aFound) and LoggedIn then
    begin
      WriteLn('Q0');
      Mouse(xz, yz, 3, 3, True);
      wait(700+Random(1000));
      if not FlagPresentH then
      begin
        WriteLn('Clicking again Q0');
        Mouse(xz, yz, 3, 3, True);
        wait(700+Random(1000));
        if not FlagPresentH then
        begin
          WriteLn('Q0 Failed AGAIN');
          insideMMClick(xz, yz, 3, 3, True);
          Wait(700+Random(1000));
        end;
      end;
      FFlag(0);
      wait(700+Random(1000));
      FFlag(0);
      wait(700+Random(1000));
    end else
    begin
      WriteLn('We didn''t get out of Lumby, probably...');
      Result := 'FailLumb';
      Exit;
    end;
    repeat
      Wait(50 + Random(25));
    until FindDTMRotatedFailSafe(Q[1], xz, yz, MMX1, MMY1, MMX2, MMY2, -Pi/4, Pi/4, Pi/60, aFound);
    if not LoggedIn then Exit;
    if FindDTMRotatedFailSafe(Q[1], xz, yz, MMX1, MMY1, MMX2, MMY2, -Pi/4, Pi/4, Pi/60, aFound) then
    begin
      WriteLn('Q1');
      Mouse((xz+10), (yz+4), 3, 3, True); //Mouse((xz+3), (yz+8), 0, 0, True);
      wait(700+Random(1000));
      if not FlagPresentH then
      begin
        WriteLn('Clicking again Q1');
        Mouse((xz+10), (yz+4), 3, 3, True);
        wait(700+Random(1000));
        if not FlagPresentH then
        begin
          WriteLn('Q1 Failed AGAIN');
          insideMMClick((xz+10), (yz+4), 3, 3, True);
          Wait(700+Random(1000));
        end;
      end;
      FFlag(0);
      wait(700+Random(1000));
      FFlag(0);
      wait(700+Random(1000));
    end;
    {repeat
      Wait(50 + Random(25));
    until FindDTMRotatedFailSafe(K[0], xz, yz, MSX1, MSY1, MSX2, MSY2, -Pi/4, Pi/4, Pi/60, aFound);}
    if not LoggedIn then Exit;
    if FindDTMRotatedFailSafe(K[0], xz, yz, 175, MSY1, MSX2, MSY2, -Pi, Pi, Pi/30, aFound) then
    begin
      WriteLn('K0(1)');
      Mouse(xz, yz, 3, 3, True);
      if not DidRedClick then
        if FindDTMRotatedFailSafe(K[0], xz, yz, 175, MSY1, MSX2, MSY2, -Pi, Pi, Pi/30, aFound) then
        begin
          WriteLn('K0(2)');
          Mouse(xz, yz, 3, 3, True);
        end;
    end else
    begin
      WriteLn('No K0(1) yet.');
      screwcompass;
      if FindDTMRotatedFailSafe(K[0], xz, yz, 105, MSY1, MSX2, MSY2, -Pi, Pi, Pi/30, aFound) then
      begin
        WriteLn('K0(3)');
        Mouse(xz, yz, 3, 3, True);
        if not DidRedClick then
          if (PercentBlackMM < 20) and FindDTMRotatedFailSafe(K[0], xz, yz, 105, MSY1, MSX2, MSY2, -Pi, Pi, Pi/30, aFound) then
          begin
            WriteLn('K0(4)');
            Mouse(xz, yz, 3, 3, True);
          end else
          begin
            WriteLn('Still no K0(4), bye!');
            Exit;
          end;
      end else
      begin
        WriteLn('Still no K0(3), bye!');
        Exit;
      end;
    end;
    repeat
      Wait(50 + Random(25));
      if ClickToContinue then
      begin
        WriteLn('Xenia is probably talking to you, did you do the Blood Pact quest?');
        TakeScreen('ClickToContinue');
        Players[CurrentPlayer].Loc := 'NoQuest';
        RandomNextPlayer(False);
      end;
    until FindDTMRotatedFailSafe(K[1], xz, yz, MSX1, MSY1, MSX2, MSY2, -Pi/4, Pi/4, Pi/60, aFound);
    if not LoggedIn then Exit;
    if FindDTMRotatedFailSafe(K[1], xz, yz, MSX1, MSY1, MSX2, MSY2, -Pi, Pi, Pi/30, aFound) then
    begin
      WriteLn('K1(1)');
      Mouse(xz, yz, 3, 3, True);
      if not DidRedClick then
        if FindDTMRotatedFailSafe(K[1], xz, yz, MSX1, MSY1, MSX2, MSY2, -Pi, Pi, Pi/30, aFound) then
        begin
          WriteLn('K1(2)');
          Mouse(xz, yz, 3, 3, True);
        end else
        begin
          WriteLn('No K1(2), bye!');
          Exit;
        end;
    end else
    begin
      WriteLn('No K1 yet.');
      screwcompass;
      if FindDTMRotatedFailSafe(K[1], xz, yz, MSX1, MSY1, MSX2, MSY2, -Pi, Pi, Pi/30, aFound) then
      begin
        WriteLn('K1(3)');
        Mouse(xz, yz, 3, 3, True);
        if not DidRedClick then
          if FindDTMRotatedFailSafe(K[1], xz, yz, MSX1, MSY1, MSX2, MSY2, -Pi, Pi, Pi/30, aFound) then
          begin
            WriteLn('K1(4)');
            Mouse(xz, yz, 3, 3, True);
          end else
          begin
            WriteLn('No K1(4), bye!');
            Exit;
          end;
      end else
      begin
        WriteLn('No K1(3), bye!');
        Exit;
      end;
    end;
    repeat
      Wait(50 + Random(25));
    until FindDTMRotatedFailSafe(K[2], xz, yz, MSX1, MSY1, MSX2, MSY2, -Pi/4, Pi/4, Pi/60, aFound);
    if not LoggedIn then Exit;
    if FindDTMRotatedFailSafe(K[2], xz, yz, MSX1, MSY1, MSX2, MSY2, -Pi, Pi, Pi/30, aFound) then
    begin
      WriteLn('K2(1)');
      Mouse(xz, yz, 3, 3, True);
      if not DidRedClick then
        if FindDTMRotatedFailSafe(K[2], xz, yz, MSX1, MSY1, MSX2, MSY2, -Pi, Pi, Pi/30, aFound) then
        begin
          WriteLn('K2(2)');
          Mouse(xz, yz, 3, 3, True);
        end else
        begin
          WriteLn('No K2(2), bye!');
          Exit;
        end;
    end else
    begin
      WriteLn('No K2 yet.');
      screwcompass;
      if FindDTMRotatedFailSafe(K[2], xz, yz, MSX1, MSY1, MSX2, MSY2, -Pi, Pi, Pi/30, aFound) then
      begin
        WriteLn('K2(3)');
        Mouse(xz, yz, 3, 3, True);
        if not DidRedClick then
          if FindDTMRotatedFailSafe(K[2], xz, yz, MSX1, MSY1, MSX2, MSY2, -Pi, Pi, Pi/30, aFound) then
          begin
            WriteLn('K2(4)');
            Mouse(xz, yz, 3, 3, True);
          end else
          begin
            WriteLn('No K2(4), bye!');
            Exit;
          end;
      end else
      begin
        WriteLn('No K2(3), bye!');
        Exit;
      end;
    end;
    repeat
      Wait(50 + Random(25));
    until FindDTMRotatedFailSafe(Q[2], xz, yz, MMX1, MMY1, MMX2, MMY2, -Pi/4, Pi/4, Pi/60, aFound);
    if not LoggedIn then Exit;
    if FindDTMRotatedFailSafe(Q[2], xz, yz, MMX1, MMY1, MMX2, MMY2, -Pi/4, Pi/4, Pi/60, aFound) then
    begin
      WriteLn('Q2');
      Mouse(xz, yz, 3, 3, True);
      Wait(100+Random(1000));
      if not FlagPresentH then insideMMClick(xz, yz, 3, 3, True);
      FFlag(6);
    end;
    repeat
      Wait(50 + Random(25));
      if (TimeFromMark(DTMFsf) > (20000+Random(5000)-Random(5000))) then
      begin
        WriteLn('Doing another click.');
        screwcompass;
        if not FlagPresentH then insideMMClick(xz, yz, 3, 3, True);
        Wait(100+Random(1000));
      end;
    until FindDTMRotatedFailSafe(Q[3], xz, yz, MMX1, MMY1, MMX2, MMY2, -Pi/4, Pi/4, Pi/60, aFound);
    if not LoggedIn then Exit;
    if FindDTMRotatedFailSafe(Q[3], xz, yz, MMX1, MMY1, MMX2, MMY2, -Pi/4, Pi/4, Pi/60, aFound) then
    begin
      WriteLn('Q3');
      Mouse(xz, yz, 3, 3, True);
      Wait(100+Random(1000));
      if not FlagPresentH then insideMMClick(xz, yz, 3, 3, True);
      FFlag(6);
    end;
    repeat
      Wait(50 + Random(25));
      if (TimeFromMark(DTMFsf) > (20000+Random(5000)-Random(5000))) then
      begin
        WriteLn('Doing another click.');
        screwcompass;
        if not FlagPresentH then insideMMClick(xz, yz, 3, 3, True);
        Wait(100+Random(1000));
      end;
    until FindDTMRotatedFailSafe(Q[4], xz, yz, MMX1, MMY1, MMX2, MMY2, -Pi/4, Pi/4, Pi/60, aFound);
    if not LoggedIn then Exit;
    if FindDTMRotatedFailSafe(Q[4], xz, yz, MMX1, MMY1, MMX2, MMY2, -Pi/4, Pi/4, Pi/60, aFound) then
    begin
      WriteLn('Q4');
      Mouse(xz, yz, 3, 3, True);
      Wait(100+Random(1000));
      if not FlagPresentH then insideMMClick(xz, yz, 3, 3, True);
      FFlag(6);
    end;
    repeat
      Wait(50 + Random(25));
      if (TimeFromMark(DTMFsf) > (20000+Random(5000)-Random(5000))) then
      begin
        WriteLn('Doing another click.');
        screwcompass;
        if not FlagPresentH then insideMMClick(xz, yz, 3, 3, True);
        Wait(100+Random(1000));
      end;
    until FindDTMRotatedFailSafe(Q[5], xz, yz, MMX1, MMY1, MMX2, MMY2, -Pi/4, Pi/4, Pi/60, aFound);
    if not LoggedIn then Exit;
    if FindDTMRotatedFailSafe(Q[5], xz, yz, MMX1, MMY1, MMX2, MMY2, -Pi/4, Pi/4, Pi/60, aFound) then
    begin
      WriteLn('Q5');
      Mouse(xz, yz, 3, 3, True);
      Wait(100+Random(1000));
      if not FlagPresentH then insideMMClick(xz, yz, 3, 3, True);
      FFlag(6);
    end;
    repeat
      Wait(50 + Random(25));
      if (TimeFromMark(DTMFsf) > (20000+Random(5000)-Random(5000))) then
      begin
        WriteLn('Doing another click.');
        screwcompass;
        if not FlagPresentH then insideMMClick(xz, yz, 3, 3, True);
        Wait(100+Random(1000));
      end;
    until FindDTMRotatedFailSafe(Q[6], xz, yz, MMX1, MMY1, MMX2, MMY2, -Pi/4, Pi/4, Pi/60, aFound);
    if not LoggedIn then Exit;
    Wait(500 + Random(25));
    if FindDTMRotatedFailSafe(Q[6], xz, yz, MMX1, MMY1, MMX2, MMY2, -Pi/4, Pi/4, Pi/60, aFound) then
    begin
      WriteLn('Q6');
      Mouse(xz, yz, 3, 3, True);
      Wait(100+Random(1000));
      if not FlagPresentH then insideMMClick(xz, yz, 3, 3, True);
      FFlag(6);
    end;
    repeat
      Wait(50 + Random(25));
      if (TimeFromMark(DTMFsf) > (20000+Random(5000)-Random(5000))) then
      begin
        WriteLn('Doing another click.');
        screwcompass;
        if not FlagPresentH then insideMMClick(xz, yz, 3, 3, True);
        Wait(100+Random(1000));
      end;
    until FindDTMRotatedFailSafe(Q[7], xz, yz, MMX1, MMY1, MMX2, MMY2, -Pi/4, Pi/4, Pi/60, aFound);
    if not LoggedIn then Exit;
    if FindDTMRotatedFailSafe(Q[7], xz, yz, MMX1, MMY1, MMX2, MMY2, -Pi/4, Pi/4, Pi/60, aFound) then
    begin
      WriteLn('Q7');
      Mouse(xz, yz, 3, 3, True);
      Wait(100+Random(1000));
      if not FlagPresentH then insideMMClick(xz, yz, 3, 3, True);
      FFlag(6);
    end;
    repeat
      Wait(50 + Random(25));
      if (TimeFromMark(DTMFsf) > (20000+Random(5000)-Random(5000))) then
      begin
        WriteLn('Doing another click.');
        screwcompass;
        if not FlagPresentH then insideMMClick(xz, yz, 3, 3, True);
        Wait(100+Random(1000));
      end;
    until FindDTMRotatedFailSafe(Q[8], xz, yz, MMX1, MMY1, MMX2, MMY2, -Pi/4, Pi/4, Pi/60, aFound);
    if not LoggedIn then Exit;
    if FindDTMRotatedFailSafe(Q[8], xz, yz, MMX1, MMY1, MMX2, MMY2, -Pi/4, Pi/4, Pi/60, aFound) then
    begin
      WriteLn('Q8');
      Mouse(xz, yz, 3, 3, True);
      Wait(100+Random(1000));
      if not FlagPresentH then insideMMClick(xz, yz, 3, 3, True);
      FFlag(6);
    end;
    repeat
      Wait(50 + Random(25));
      if (TimeFromMark(DTMFsf) > (20000+Random(5000)-Random(5000))) then
      begin
        WriteLn('Doing another click.');
        screwcompass;
        if not FlagPresentH then insideMMClick(xz, yz, 3, 3, True);
        Wait(100+Random(1000));
      end;
    until FindDTMRotatedFailSafe(Q[9], xz, yz, MMX1, MMY1, MMX2, MMY2, -Pi/4, Pi/4, Pi/60, aFound);
    if not LoggedIn then Exit;
    if FindDTMRotatedFailSafe(Q[9], xz, yz, MMX1, MMY1, MMX2, MMY2, -Pi/4, Pi/4, Pi/60, aFound) then
    begin
      WriteLn('Q9');
      Mouse(xz, yz, 3, 3, True);
      Wait(100+Random(1000));
      if not FlagPresentH then insideMMClick(xz, yz, 3, 3, True);
      FFlag(6);
    end;
    repeat
      Wait(50 + Random(25));
      if (TimeFromMark(DTMFsf) > (20000+Random(5000)-Random(5000))) then
      begin
        WriteLn('Doing another click.');
        screwcompass;
        if not FlagPresentH then insideMMClick(xz, yz, 3, 3, True);
        Wait(100+Random(1000));
      end;
    until FindDTMRotatedFailSafe(Q[10], xz, yz, MMX1, MMY1, MMX2, MMY2, -Pi/4, Pi/4, Pi/60, aFound);
    if not LoggedIn then Exit;
    if FindDTMRotatedFailSafe(Q[10], xz, yz, MMX1, MMY1, MMX2, MMY2, -Pi/4, Pi/4, Pi/60, aFound) then
    begin
      WriteLn('Q10');
      Mouse(xz, yz, 3, 3, True);
      Wait(100+Random(1000));
      if not FlagPresentH then insideMMClick(xz, yz, 3, 3, True);
    end else
      Mouse(xz, yz, 3, 3, True);
    FFlag(0);
    if not LoggedIn then Exit;
    blkcolor:=SRL_GetBlackBackground;
    if (blkcolor <> -1) then
      if (GetColor(676, 69) <> blkcolor) then // probably didn't click properly on mm
      begin
        WriteLn('Clicking last point one last time, blindly.');
        wait(100+random(500));
        FFlag(0);
        MouseBox(669, 62, 693, 79, 1);
        FFlag(0);
      end else
        WriteLn('We are in last chamber probably.');

    Wait(500 + Random(25));
    Writeln('We have reached our Final Destination!');
    stats_IncVariable('Caves Entered',1);
    Inc(DethWelks);
    markTime(lasthpbar);
    Result := 'Walked';
    FFlag(0);
    Wait(2000+Random(3000));
    MouseSpeed := MOUSE_SPEED + Random(MOUSE_SPEED_RANDOMNESS);
    CustomPickup;
    BuryBones;
    if KilledYou then
    begin
      WriteLn('You got killed, so we will switch world to prevent bugged monster.');
      ChangeWorld(RandomWorld(Players[CurrentPlayer].Member, False));
      KilledYou := False;
      Exit;
    end;
    ClickNorth(SRL_ANGLE_HIGH);
  finally
    try
      FreeDTM(Q[0]);
      FreeDTM(Q[1]);
      FreeDTM(Q[2]);
      FreeDTM(Q[3]);
      FreeDTM(Q[4]);
      FreeDTM(Q[5]);
      FreeDTM(Q[6]);
      FreeDTM(Q[7]);
      FreeDTM(Q[8]);
      FreeDTM(Q[9]);
      FreeDTM(Q[10]);
      FreeDTM(K[0]);
      FreeDTM(K[1]);
      FreeDTM(K[2]);
    except
      WriteLn('DTM Freeing Failed!');
    end;
  end;
end;

procedure GetReadyToRespawn(whyme: string);
var tmpz,ii,zzx,zzy: integer; walkerz: string;
begin
  if (GetColor(304, 27) = 12378347) or FindSymbol(zzx,yyy,'water') or (whyme = 'force') then // yellow on dead screen
  begin
    WriteLn('Oh dear you are dead :(');
    Wait(1000+Random(2000));
    if (GetColor(413, 7) = 0) then
    begin
      MouseBox(186, 298, 330, 318, 1); // Confirm death button.
      KilledYou := True;
    end else
      KilledYou := False;
    tmpz := 0;
    xxx := 257-random(30)+random(30);
    yyy := 200-random(30)+random(30);
    Players[CurrentPlayer].Loc := 'Dead';
    repeat
      inc(tmpz)
      Wait(1001+Random(1000));
      if (GetColor(413, 7) <> 0) or (tmpz > 5) then // black color on background goes away when screen closed
        Break;
    until (tmpz > 5); // just incase...

    for ii := 1 to 4 do // put back on armour and stuff
      if ExistsItem(ii) then
      begin
        MMouseItem(ii);
        Wait(100+Random(500));
        if not IsUpText('Use') then
        begin
          GetMousePos(zzx,zzy);
          Mouse(zzx,zzy,0,0,True);
        end;
      end;

    walkerz := DoDeathWalk;
    if (walkerz <> 'Walked') then
    begin
      WriteLn('Deathwalk didn''t work properly!');
      if (walkerz = 'FailLumb') then
      begin
        if not LoggedIn then LoginPlayer;
        WriteLn('Lumbridge Walk failed. Teleport home and let''s try again.');
        GameTab(tab_Magic);
        Wait(100+Random(500));
        GameTab(tab_Magic);
        Wait(100+Random(500));
        Mouse(575, 230,5,5,True); // TP home
        Wait(15000+Random(7000)); // ~13 sec max for home teleport
        walkerz := DoDeathWalk;
        if (walkerz <> 'Walked') then
        begin
          WriteLn('Failed AGAIN! Too bad!');
          Players[CurrentPlayer].Loc := 'FailWalks';
          if LoggedIn then TakeScreen('FailWalk');
          RandomNextPlayer(False);
        end else
        begin
          WriteLn('Walk worked second time, yay!');
          Exit;
        end;
      end;

    end else
      WriteLn('Deathwalk worked!');

  end;
end;

procedure RandomRClickH; // phantombmx/EvilChicken - removed inv clicking
var
  M: Byte;
  Inv: Boolean;
  bx,by: integer;
begin
  if (not LoggedIn) then exit;
  M := MouseSpeed;
  MouseSpeed := 7 + Random(25);
  bx := Random(MIX2);
  by := Random(MIY2);
  if PointInBox(point(bx,by),inttobox(MSX1,MSY1,msx2,msy2)) then
  begin
    Mouse(bx, by, 0, 0, False);
    if (Random(3) > 0) then
      Inv := ChooseOption('xamine');
    if (not Inv) then ChooseOption('ancel');
  end
  else
    MMouse(bx, by, 0, 0);
  MouseSpeed := M;
end;

procedure AntiBan_Short(disg:string; waitz:integer);
begin
  while (waitz > 0) do
  begin
    status(disg+': '+tostr(waitz)+'ms');
    case (Random(200)) of
      0: begin RandomRClickH; Inc(Players[CurrentPlayer].Integers[2]); Inc(AntiBansGlobal); end;
      1: begin MouseSpeed := MOUSE_SPEED + Random(MOUSE_SPEED_RANDOMNESS); Inc(Players[CurrentPlayer].Integers[2]); Inc(AntiBansGlobal); end;
      2: begin if (Random(2) = 0) then PickUpMouse; Inc(Players[CurrentPlayer].Integers[2]); Inc(AntiBansGlobal); end;
      3..200: begin
        wait(1);
      end;
    end;
    Wait(100+random(500));
    waitz:=waitz-(100+random(500));
  end;
end;

procedure CheckPowerLevels;
var x,y:integer;
begin
  if not LoggedIn or LobbyScreen then
    Exit;
  if TrainLowest then
  begin
    Players[CurrentPlayer].Integers[6] := GetSkillLevel(Skill_Attack);
    Players[CurrentPlayer].Integers[7] := GetSkillLevel(Skill_Strength);
    Players[CurrentPlayer].Integers[8] := GetSkillLevel(Skill_Defence);
    GameTab(tab_Combat);
    wait(300+Random(700));
    if (IsTextInAreaEx(576, 209, 725, 230, x, y, 'ling', 0, NPCChars, False, False, 0, 2, 2070783)) then
    begin
      WriteLn('You have a sling attached, please disable TrainLowest const!');
      Exit;
    end;
    if Players[CurrentPlayer].Integers[7] < Players[CurrentPlayer].Integers[6] then
    begin  // Borrowed some logic from Tarajunky
      if Players[CurrentPlayer].Integers[8] < Players[CurrentPlayer].Integers[7] then
        SetFightMode(4)
      else
        SetFightMode(2);
    end else
    begin
      if Players[CurrentPlayer].Integers[8] < Players[CurrentPlayer].Integers[6] then
        SetFightMode(4)
      else
        SetFightMode(1);
    end;
  end;
end;

Function nInFight: Boolean; // Narcle!
var
  T: TPoint;
  H, I: integer;
  ATPA: T2DPointArray;
  FightBarColors: TIntegerArray;
  InFightBox: TBox;
begin
  InFightBox := IntToBox(224, 115, 294, 150);
  FightBarColors := [10240, 9728, 132923];
  H := High(FightBarColors);
  SetArrayLength(ATPA, H+1);
  T := MiddleBox(InFightBox);
  for i := 0 to H do
    with InFightBox do
    FindColorsSpiralTolerance(T.x, T.y, ATPA[i], FightBarColors[i], X1, Y1, X2, Y2, 0);
  Result := InRange(Length(MergeATPA(ATPA)), 30, 240);
  if Result then
  begin
    MarkTime(lasthpbar);
    tmpbarz := 0;
  end;
  //writeln(result);
end;

{function FindObjTPAH(var X, Y: Integer; Color, Tol, CTS, ObjWidth, ObjHeight, minCount: Integer; UpText: TStringArray): Boolean; // Wizzup!? - unused ATM
var
  I, tCTS: Integer;
  myPoint: TPoint;
  Points: TPointArray;
  aPoints: T2DPointArray;
begin
  Result := False;
  if not LoggedIn then exit;
  tCTS := GetColorToleranceSpeed;
  CTS := Integer(CTS * 9 mod 3 <> 0);
  ColorToleranceSpeed(CTS);
  FindColorsSpiralTolerance(X, Y, Points, Color, MSX1, MSY1, MSX2, MSY2, Tol);
  if Length(Points) = 0 then
  begin
    ColorToleranceSpeed(tCTS);
    Exit;
  end;
  ColorToleranceSpeed(1);
  aPoints := TPAtoATPAEx(Points, ObjWidth, ObjHeight);
  SetLength(Points, 0);
  for I := 0 to High(aPoints) do
  begin
    if Length(aPoints[i]) < minCount then
      Continue;
    myPoint := MiddleTPA(aPoints[i]);
    MMouse(myPoint.X-random(5)+random(5), myPoint.Y-random(5)+random(5), 0, 0);
    if WaitUpTextMulti(UpText, 300) then
    begin
      GetMousePos(X, Y);
      Result := True;
      ColorToleranceSpeed(tCTS);
      Exit;
    end;
  end;
  ColorToleranceSpeed(tCTS);
end;}

procedure EatSnacks;
var chen,ex,ey: integer;
begin
  if Players[CurrentPlayer].Integers[86] = 1488 then // no food left
    Exit;
  for chen := 1 to 28 do
  begin
    if ExistsItem(chen) then
    begin
      MMouseItem(chen);
      if IsUpText('Eat ') then
      begin
        WriteLn('Eating foodstuffs in slot '+tostr(chen)+'!');
        GetMousePos(ex,ey);
        Mouse(ex,ey,0,0,True);
        Antiban_Short('Eating',1000+Random(1000));
        if ExistsItem(chen) then
          Wait(1001+Random(1000));
        stats_IncVariable('Lobster Eaten',1); // most generic var name on stats sadly
        Exit;
      end;
    end;
  end;
  Players[CurrentPlayer].Integers[86] := 1488; // this will only happen if inv is empty / not matching uptext
  WriteLn('Your inv doesn''t have any food in it / it doesn''t match "Eat" uptext.');
  WriteLn('Feel free to put some food in your inv and it will be eaten at Red/Orange HP!');
end;

procedure KeepHealthy;
var somerandomvar: integer; current: string;
begin
  if not EatFoods then
    Exit;
  current := 'whee';
  somerandomvar := GetMMLevels('hp',current);
  case current of
    'Red','Orange': begin EatSnacks; if not ninfight or invfull then burybones; end;
  end;
end;

procedure TurnOffOnScreenXPPopup;
var hx,hy:integer;
begin
  if Players[CurrentPlayer].Booleans[94] then
    Exit;
  if FindDTM(Herz,hx,hy,MSX1,MSY1,MSX2,MSCY-30) then
  begin
    WriteLn('Found XP on-screen popup. Turning it off.');
    MouseBox(521, 51, 546, 75, mouse_Right);
    Wait(10+Random(100));
    ChooseOption('op-up');
    Players[CurrentPlayer].Booleans[94] := True;
  end;
end;

function FindVictim: Boolean;
var breakingthefight,expz,recentone,lastdtm,xz,yz,statuestatus: integer; gottagofast:boolean;
begin
  Result := False;
  statuestatus := 0;
  if sonic then
    gottagofast:=True
  else
    gottagofast:=False;
  sonic := False;
  if not loggedin then
    Exit;

  if WORLD_LEAVE then
    if (TimeFromMark(PlayerSessionTime) > WorldLeaveMarker) then
    begin
      WriteLn('Time''s up! Switching world.');
      if HowManyPlayers = 1 then
        ChangeWorld(RandomWorld(Players[CurrentPlayer].Member, False))
      else
        RandomNextPlayer(True);
    end;
  Inc(thetries);
  if (xxx < 150) or (xxx < 150) then
  begin
   // not really needed anymore WriteLn('recalibrated xxx,yyy coords');
    xxx := 257-random(30)+random(30);
    yyy := 200-random(30)+random(30);
  end;
  GetReadyToRespawn('');
  TurnOffOnScreenXPPopup;
  expz:=GetXPBarTotal;
  if FindDTMRotated(YesS, xxx, yyy, MSX1, MSY1, MSX2, MSY2, -Pi/4, Pi/4, Pi/30, aFound) then
    statuestatus := 1;
  if (statuestatus = 0) and FindDTMRotated(NoS, xxx, yyy, MSX1, MSY1, MSX2, MSY2, -Pi/4, Pi/4, Pi/30, aFound) then
    statuestatus := 2;

  if statuestatus <> 0 then
  begin

    if DrawDebugs then
      if (statuestatus = 1) then
        SMART_DrawBox(inttobox(xxx-15,yyy-11,xxx+1,yyy+11))
      else
        SMART_DrawBox(inttobox(xxx+1,yyy-5,xxx+17,yyy+11));

    if (not gottagofast) and not isUpTextMultiCustom(['ouch P','ake Di']) then
    begin
      if (statuestatus = 1) then
        mmouse(xxx-5,yyy+3,8,8)
      else
        mmouse(xxx+9,yyy+3,8,8);
      //writeln(GetUpText);
    end
    else
      if gottagofast then
        mouse(xxx-9,yyy-9,8,8,mouse_Left)
      else
        WriteLn('Mouse already over uptext: '+getUpText);

    if gottagofast or WaitUpTextMulti(['ouch P','ake Di'], 300)then
    begin
      if gottagofast then
      begin
        Writeln('SANIC');
        if DidYellowClick then
        begin
          WriteLn('Misclicked... oh nooo.');
          Exit;
        end else
          WriteLn('Went fast!');
      end;
      result := true;
      Getmousepos(xxx,yyy);
      mouse(xxx,yyy,0,0,true);
      if DidYellowClick then
      begin
        WriteLn('Misclicked! Try again.');
        Exit;
      end;
      WriteLn('Statue clicked.');
      Inc(MonstersKilledGlobal);
      IncEx(ExpGainGlobal,133);
      IncEx(Players[CurrentPlayer].Integers[69],133);
      Players[CurrentPlayer].Integers[25] := 0;
      stats_IncVariable('Total EXP Gained', 133);
      stats_IncVariable('Monsters Killed', 1);
      thetries := 0;
      Result := True;
      antiban_short('AttackWait', 5000+Random(3000));
      breakingthefight := 0;
      repeat
        inc(breakingthefight);
        antiban_short('WaitingAttack', 100+Random(500));
        TurnOffOnScreenXPPopup;
        GetReadyToRespawn('');
        findnormalrandoms;
        recentone := (GetXPBarTotal-expz);
        if (recentone>=133) and (recentone<=999) then // make sure no false detection
        begin
          writeLn('You (probably) killed it, 133 exp for you!');
          break;
        end;
        if (TimeFromMark(lasthpbar) > 60000+Random(20000)-Random(20000)) then
        begin
          if (tmpbarz > 1) then
          begin
            TakeScreen('StillNoHPBar');
            Writeln('No HP bar after switching worlds... going to kill your player, sorry!');
            Players[CurrentPlayer].Loc := 'NoHPBar';
            RandomNextPlayer(False);
            tmpbarz := 0;
            Exit;
          end
          else
          begin
            //TakeScreen('NoHPBar');
            inc(tmpbarz);
            WriteLn('No HP Bar for over over a minute, something might be wrong!');
            Writeln('Reconnecting just in case.');
            Logout;
            Wait(1000+Random(4000));
            LoginPlayer;
            Exit;
          end;
        end;
        if not nInFight then Break else tmpbarz := 0; // DON'T CHANGE THIS ORDERING
        KeepHealthy;
      until (breakingthefight > 150); // I dunno, about 50 sec?
      if (breakingthefight > 150) then
        WriteLn('We took quite a bit to kill him, something might be wrong...');
      antiban_short('KilledWait',500+random(2488));
      CustomPickup;
      BuryBones;
      SetColorToleranceSpeed(1);
      SetColorspeed2Modifiers(0.2,0.2);
      Exit;

    end;

  end;
  if Result then wait(500+random(2000)) else wait(100+random(500));

  if(thetries = 2)or(thetries = 10)or(thetries = 20)or(thetries=40)then
    if (PercentBlackMM > 20) then
    begin
      //TakeScreen('MiniMapClick');
      Writeln('you maybe moved away? clicking minimap.');
      lastdtm := DTMFromString('mwQAAAHic42RgYNACYjsGCGACYm4glgViTSA2AmJzIBaAyrMDsTBUXg6IZYBYAoh5gTgyKIyBEOAnAjMSgeEAALnOA2U=');

      if FindDTMRotated(lastdtm, xz, yz, MMX1, 69, MMX2, MMY2, -Pi/4, Pi/4, Pi/60, aFound) then
      begin
        WriteLn('DTM Walking');
        Mouse(xz+random(3), yz+random(15), 3, 3, True);
        FFlag(0);
        sonic := True;
      end else
      begin
        WriteLn('Blind Walking');
        mousebox(647,107,676,138,1);
        sonic := True;
      end;
      try freeDTM(lastDTM); except WriteLn('DTM Free Failed'); end;
      antiban_short('BlindClick',100);
      flag;
    end
    else
      WriteLn('We would blind click but we probably aren''t underground, not enough black.');

  if(thetries > 50)then
  begin
    //TakeScreen('NoObj');
    writeln('no object 50 times, your player is a bit broken...');
    thetries := 0;
    Players[CurrentPlayer].Loc := 'NoObj';
    if (Players[CurrentPlayer].Integers[25] <> 0) then
    begin
      TakeScreen('NoObjFatal');
      RandomNextplayer(False);
    end
    else
    begin
      Inc(Players[CurrentPlayer].Integers[25]);
      GetReadyToRespawn('force');
    end;
    Exit;
  end;
  writeln('No object found ('+tostr(thetries)+' tries); did you steal the statue yet? You MUST have stolen the statue off the platter before running script! Make sure you stand next to it. Also make sure you''re on lowest grafix settings+highest brightness.');

  if(thetries=13)then
  begin
    MakeCompass('rand');
    ClickNorth(SRL_ANGLE_HIGH);
  end;

  if(thetries = 29)or(findsymbol(xz,yz,'water'))then
  begin
    WriteLn('Going to try deathwalk.');
    GetReadyToRespawn('force');
  end;

end;

procedure PrintReports;
var
  QC: array [0..1] of TStringArray; // Query = 0, Counter = 1.
  I, II: Byte;
begin
  if (TimeFromMark(ReportClear) > ClearTime*60000) then
  begin
    ClearDebug;
    MarkTime(ReportClear);
  end;
  WriteLn('[REPORT]');
  SRLRandomsReport;
  WriteLn('');

  for II := 0 to 1 do
    SetArrayLength(QC[II], 4);

  QC[0] := ['Total runtime:',
    'Players active:',
    'Monsters killed:',
    '-> Monsters killed per hour:'];
  QC[1] := [TimeRunning,
    ToStr(PlayersActive) + ' out of ' + ToStr(HowManyPlayers),
    ToStr(MonstersKilledGlobal),
    ToStr((3600 * (MonstersKilledGlobal)) div (GetTimeRunning div 1000 + 1))];

  WriteLn('<!---');
  WriteLn('<! ' + Padr('Harry''s ' + SCRIPT_NAME, 35) + 'v' + SCRIPT_VERSION);
  WriteLn('<!---');

  II := High(QC[0]);
  for I := 0 to II do
    WriteLn('<! ' + Padr(QC[0][I], 32) + QC[1][I]);

  WriteLn('<!---');
  WriteLn('<! ## | Nick | A | CB. | ExpGain/Hr: | Rand:')

  for I := 0 to HowManyPlayers - 1 do
    WriteLn('<! ' + Padr(ToStr(I),                                 3) +
      '| ' + Padr(Copy(Players[I].Nick, 1, 4),                     5) +
      '| ' + Padr(ToStr(Players[I].Active)[1],                     2) +
      '| ' + Padr(ToStr(Players[I].Integers[44]), 4) +
      '| ' + Padr(ToStr(Players[I].Integers[69])+'/'+ToStr((3600 * (Players[I].Integers[69])) div (GetTimeRunning div 1000 + 1)),12) +
      '| ' + Players[I].Rand);

  WriteLn('<! Total anti-ban procedures run: '+ inttostr(AntiBansGlobal));
  if WORLD_LEAVE then
    WriteLn('<! World-hop in: '+ tostr(((Worldleavemarker + PlayerSessionTime) - (GetSystemTime)) div 60000) +' minutes.');
  if DethWelks > 0 then
    WriteLn('<! Death-walked '+toStr(DethWelks)+' times.');
  if BonesBurriedGlobal > 0 then
    WriteLn('<! Burried '+tostr(bonesburriedglobal)+' bones.');

  if (TimeFromMark(StatsTimer) > 360000) then // 6 minutes.
  begin
    Stats_Commit;
    MarkTime(StatsTimer);
    WriteLn('<! Sent stats in!');
  end;

  if (SRLStats_Username = '') then
    WriteLn('<! Please consider getting your own stats username @ http://stats.villavu.com');

  WriteLn('<!---');
  WriteLn('[/REPORT]');
end;

procedure Player_OnLogIn;
begin
  Wait(1000+Random(2000));
  if (FindNormalRandoms) then
    if (not Players[CurrentPlayer].Active) then
    begin
      WriteLn('Player is in a random.');
      LogOut;
      Players[CurrentPlayer].Active := False;
      Players[CurrentPlayer].Status := 'InRandom';
      Exit;
    end;

  CheckPowerLevels;
  MarkTime(PlayerSessionTime);
  MarkTime(lasthpbar);
  WorldLeaveMarker := (2100000 + Random(1500000) - Random(1500000)); // 2100000 ms = 35 minutes. 1500000 ms = 25 minutes. Add and subtract the 25 minutes from 35 giving a huge change of randomness for world-switching.
  //Writeln(tostr(worldleavemarker));
  ClickNorth(SRL_ANGLE_HIGH);
  SetRun(True);
  Retaliate(True);
  Players[CurrentPlayer].Integers[44]:=GetCombatLevel;
  if (Players[CurrentPlayer].Integers[44] < 20) and (Players[CurrentPlayer].Integers[44] > 2) then
  begin
    WriteLn('/!\ ACHTUNG! /!\');
    WriteLn('Your combat level is low, so you will probably die a lot.');
    WriteLn('Be warned, your exp/hr will be low due to this!');
  end;
  if (GetColor(433, 499) = 65280) then // assist on
  begin
    MouseBox(412, 485, 452, 497, 2);
    Wait(10+Random(100));
    ChooseOption('Off');
  end;
end;

procedure Autoupdateme;
var ClientUp, Neifile:integer;
    OnlineVersion, NewScript, NeiFeilNennen:string;
begin
  if Autochecken then
  begin
    writeln('Checking for script updates...');
    ClientUp := InitializeHTTPClient(False, False);
    SetHTTPUserAgent(ClientUp,'Simba ' + SCRIPT_VERSION);
    OnlineVersion := GetHTTPPage(ClientUp,'http://harry.lu/srl/catacomb-version.txt');
    writeln(onlineversion);
    writeln(script_version)
    FreeHTTPClient(ClientUp);
    if (Length(trim(OnlineVersion)) = 3) and (trim(OnlineVersion) > SCRIPT_VERSION) then
    begin
      writeLn('Newer script version online!');
      writeLn('Autoupdating to newer version.');
      ClientUp := InitializeHTTPClient(False,False);
      SetHTTPUserAgent(ClientUp,'Simba');
      NewScript := GetHTTPPage(ClientUp,'http://harry.lu/srl/catacomb-current.txt');
      FreeHTTPClient(ClientUp);

      NeiFeilNennen := AppPath + SCRIPT_NAME + ' v'+trim(OnlineVersion)+' [Pub] by Harry.simba';
      Neifile := Rewritefile(NeiFeilNennen, true);
      try
        WriteFileString(Neifile, NewScript);
      except
        begin
          writeLn('Fatal error writing to '+NeiFeilNennen+'!!');
          terminatescript;
        end;
      end;
      CloseFile(Neifile);
      writeLn('New script downloaded and saved at '+NeiFeilNennen+' !! Please use this!');
      TerminateScript;
    end else
    begin
      if (Length(trim(OnlineVersion)) <> 3) then
        WriteLn('Version checking failed (debug: length was not equal), you might be outdated.')
        else writeLn('You have the latest version of the script!');
      exit;
    end;
  end else
    WriteLn('!!!!! Not checking for latest version, you may be outdated!');
end;

procedure FreeGlobalDTMs;
begin
  try
    FreeDTM(YesS);
    FreeDTM(NoS);
    FreeDTM(Herz);
  except
    WriteLn('FreeDTM Failed!');
  end;
  writeln('Thanks for running my script, please post proggies on http://villavu.com/forum/showthread.php?t=69540 !');
end;

procedure CrashSMART;
begin
  Writeln('You are using CRASHSMART, so we are going to reload your client after the RS update!');
  SmartgetFieldObject(1488,'crash'); // will crash SMART (and Simba).
  // IF THIS DOES NOT CRASH YOUR SIMBA, YOU ARE NOT USING THE PROPER PLUGIN
  // AN ACCESS VIOLATION HERE IS NOT THE CRASH; MAKE SURE YOU MOVED THE EDITED PLUGIN
  Wait(5000);
  WriteLn('CRASHSMART Failed: Make sure you are using the proper plugin!');
  WriteLn('Read more about this feature at http://villavu.com/forum/showthread.php?t=67864');
  TerminateScript;
end;

procedure SetUpScript;
var
  i,xxx,yyy: Integer;
begin
  ClearDebug;

  Smart_Server := SERVER;
  Smart_Signed := SIGNED;
  Smart_Members:= MEMBERS;

  Autoupdateme;

  SetupSRL;
  Screenshots := GetScreenies;
  Reincarnate := True;
  DeclarePlayers;
  LampSkill := 'hitpoints';
  SmartSetRefresh(100); // highest fps

  YesS:=DTMFromString('mwQAAAHic42RgYFAA4gQgjgViJwYIUAZiWSBWBWIJIBaEiqsAsTEQ6wOxIRALA7E4EPMA8bS+JgZsoLIoA475gXxCmJEIDAcA7AAI0w==');
  NoS:=DTMFromString('mrAAAAHic42BgYJAE4jggDgNiVQYIEANiJSAWBmJ2IGYBYhUg1oBiTiDmgartX7qEAR3UTJoMx/xAPj7MSADDAABsOAkV');
  Herz:=DTMFromString('mbQAAAHicY2VgYNBlZWBQBmIrIDYDYn0gNgeKewKxGxCHQ7GSkhIcJyUlM+ycwcjADxRHx4xYMBgAAKPDBn0=');

  AddOnTerminate('FreeGlobalDTMS');


  if (SRLStats_Username = '') then
    SetupSRLStats(354, 'Anonymous', 'anon1337')
  else
    SetupSRLStats(354, SRLStats_Username, SRLStats_Password);

  MouseSpeed := MOUSE_SPEED + Random(MOUSE_SPEED_RANDOMNESS);
  SRL_Procs[srl_OnLogIn] := @Player_OnLogIn;
  SRL_Procs[srl_OnRSUpdate] := @CrashSMART;

  for i := 0 to High(Players) do
  begin
    if (WORLD_SWITCH) then
      Players[i].WorldInfo := [Players[i].Member, -1, False];
    Players[i].Integers[4] := 1;
  end;

  CurrentPlayer := RandomPlayerIndex;
  ActivateClient;
  MarkTime(ProperLog);
  MarkTime(ReportClear);
  MarkTime(lasthpbar);
  xxx := 257-random(30)+random(30);
  yyy := 200-random(30)+random(30);
  Wait(1000 + Random(2000));
end;

procedure MainLoop;
begin
  CurrentPlayer := RandomPlayerIndex;
  LogInPlayer;

  repeat
    repeat
      if (TimeFromMark(ReportTimer) > 60000) then // 1 minute
      begin
        PrintReports;
        MarkTime(ReportTimer);
      end;
      FindVictim;
      if (not LoggedIn) then
      begin
        WriteLn('Not logged in?');
        mmouse(random(msx2),random(msy2),0,0);
        Wait(500+Random(1000));
        if (not LoggedIn) then Break else Wait(1);
      end;
      if LobbyScreen then
      begin
        WriteLn('At lobby screen?');
        Wait(500+Random(1000));
        if (LobbyScreen) then Break else Wait(1);
      end;
    until(False);
    if LobbyScreen then
      LeaveLobby;

    WriteLn('Detected as logged out, NPlayer');
    RandomNextPlayer(Players[CurrentPlayer].Active);
  until False;
end;

begin
  SetUpScript;
  MainLoop;
end.
